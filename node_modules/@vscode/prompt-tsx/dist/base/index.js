"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation and GitHub. All rights reserved.
 *--------------------------------------------------------------------------------------------*/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toVsCodeChatMessages = exports.renderPrompt = exports.PromptRenderer = exports.MetadataMap = exports.PromptElement = exports.UserMessage = exports.TextChunk = exports.SystemMessage = exports.PrioritizedList = exports.FunctionMessage = exports.AssistantMessage = exports.ChatRole = void 0;
const openai_1 = require("./openai");
const promptRenderer_1 = require("./promptRenderer");
const tokenizer_1 = require("./tokenizer/tokenizer");
var openai_2 = require("./openai");
Object.defineProperty(exports, "ChatRole", { enumerable: true, get: function () { return openai_2.ChatRole; } });
__exportStar(require("./results"), exports);
__exportStar(require("./tsx-globals"), exports);
__exportStar(require("./types"), exports);
var promptElements_1 = require("./promptElements");
Object.defineProperty(exports, "AssistantMessage", { enumerable: true, get: function () { return promptElements_1.AssistantMessage; } });
Object.defineProperty(exports, "FunctionMessage", { enumerable: true, get: function () { return promptElements_1.FunctionMessage; } });
Object.defineProperty(exports, "PrioritizedList", { enumerable: true, get: function () { return promptElements_1.PrioritizedList; } });
Object.defineProperty(exports, "SystemMessage", { enumerable: true, get: function () { return promptElements_1.SystemMessage; } });
Object.defineProperty(exports, "TextChunk", { enumerable: true, get: function () { return promptElements_1.TextChunk; } });
Object.defineProperty(exports, "UserMessage", { enumerable: true, get: function () { return promptElements_1.UserMessage; } });
var promptElement_1 = require("./promptElement");
Object.defineProperty(exports, "PromptElement", { enumerable: true, get: function () { return promptElement_1.PromptElement; } });
var promptRenderer_2 = require("./promptRenderer");
Object.defineProperty(exports, "MetadataMap", { enumerable: true, get: function () { return promptRenderer_2.MetadataMap; } });
Object.defineProperty(exports, "PromptRenderer", { enumerable: true, get: function () { return promptRenderer_2.PromptRenderer; } });
async function renderPrompt(ctor, props, endpoint, tokenizerMetadata, progress, token, mode = 'vscode') {
    let tokenizer = 'countTokens' in tokenizerMetadata
        ? new tokenizer_1.AnyTokenizer((text, token) => tokenizerMetadata.countTokens(text, token))
        : tokenizerMetadata;
    const renderer = new promptRenderer_1.PromptRenderer(endpoint, ctor, props, tokenizer);
    let { messages, tokenCount, references } = await renderer.render(progress, token);
    const metadatas = renderer.getAllMeta();
    const usedContext = renderer.getUsedContext();
    if (mode === 'vscode') {
        messages = toVsCodeChatMessages(messages);
    }
    return { messages, tokenCount, metadatas, usedContext, references };
}
exports.renderPrompt = renderPrompt;
/**
 * Converts an array of {@link ChatMessage} objects to an array of corresponding {@link LanguageModelChatMessage VS Code chat messages}.
 * @param messages - The array of {@link ChatMessage} objects to convert.
 * @returns An array of {@link LanguageModelChatMessage VS Code chat messages}.
 */
function toVsCodeChatMessages(messages) {
    const vscode = require('vscode');
    return messages.map((m) => {
        switch (m.role) {
            case openai_1.ChatRole.Assistant:
                return vscode.LanguageModelChatMessage.Assistant(m.content, m.name);
            case openai_1.ChatRole.User:
                return vscode.LanguageModelChatMessage.User(m.content, m.name);
            case openai_1.ChatRole.Function: {
                const message = vscode.LanguageModelChatMessage.User('');
                message.content2 = new vscode.LanguageModelChatMessageFunctionResultPart(m.name, m.content);
                return message;
            }
            default:
                throw new Error(`Converting chat message with role ${m.role} to VS Code chat message is not supported.`);
        }
    });
}
exports.toVsCodeChatMessages = toVsCodeChatMessages;
