"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation and GitHub. All rights reserved.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.PromptRenderer = exports.MetadataMap = void 0;
const promptElements_1 = require("./promptElements");
const arrays_1 = require("./util/arrays");
var MetadataMap;
(function (MetadataMap) {
    MetadataMap.empty = {
        get: () => undefined
    };
})(MetadataMap || (exports.MetadataMap = MetadataMap = {}));
/**
 * A prompt renderer is responsible for rendering a {@link PromptElementCtor prompt element} to {@link ChatMessagePromptElement chat messages}.
 *
 * Note: You must create a fresh prompt renderer instance for each prompt element you want to render.
 */
class PromptRenderer {
    /**
     *
     * @param _endpoint The chat endpoint that the rendered prompt will be sent to.
     * @param _ctor The prompt element constructor to render.
     * @param _props The props to pass to the prompt element.
     */
    constructor(_endpoint, _ctor, _props, _tokenizer) {
        this._endpoint = _endpoint;
        this._ctor = _ctor;
        this._props = _props;
        this._tokenizer = _tokenizer;
        // map the constructor to the meta data instances
        this._meta = new Map();
        this._usedContext = [];
        this._ignoredFiles = [];
        this._root = new PromptTreeElement(null, 0);
        this._references = [];
    }
    getAllMeta() {
        const metadataMap = this._meta;
        return {
            get(key) {
                return metadataMap.get(key);
            }
        };
    }
    getIgnoredFiles() {
        return Array.from(new Set(this._ignoredFiles));
    }
    getMeta(key) {
        return this._meta.get(key);
    }
    getUsedContext() {
        return this._usedContext;
    }
    createElement(element) {
        return new element.ctor(element.props);
    }
    async _processPromptPieces(sizing, pieces, progress, token) {
        // Collect all prompt elements in the next flex group to render, grouping
        // by the flex order in which they're rendered.
        const promptElements = new Map();
        for (const [i, element] of pieces.entries()) {
            // Set any jsx children as the props.children
            if (Array.isArray(element.children)) {
                element.props = (element.props ?? {});
                element.props.children = element.children; // todo@joyceerhl clean up any
            }
            // Instantiate the prompt part
            if (!element.ctor) {
                throw new Error(`Invalid ChatMessage child! Child must be a TSX component that extends PromptElement.`);
            }
            const promptElement = this.createElement(element);
            element.node.setObj(promptElement);
            // Prepare rendering
            const flexGroupValue = element.props.flexGrow ?? Infinity;
            let flexGroup = promptElements.get(flexGroupValue);
            if (!flexGroup) {
                flexGroup = [];
                promptElements.set(flexGroupValue, flexGroup);
            }
            flexGroup.push({ order: i, element, promptElementInstance: promptElement });
        }
        const flexGroups = [...promptElements.entries()].sort(([a], [b]) => b - a).map(([_, group]) => group);
        const setReserved = (groupIndex, reserved) => {
            const sign = reserved ? 1 : -1;
            for (let i = groupIndex + 1; i < flexGroups.length; i++) {
                for (const { element } of flexGroups[i]) {
                    if (element.props.flexReserve) {
                        sizing.consume(sign * element.props.flexReserve);
                    }
                }
            }
        };
        // Prepare all currently known prompt elements in parallel
        for (const [groupIndex, promptElements] of flexGroups.entries()) {
            // Temporarily consume any reserved budget for later elements so that the sizing is calculated correctly here.
            setReserved(groupIndex, true);
            // Calculate the flex basis for dividing the budget amongst siblings in this group.
            let flexBasisSum = 0;
            for (const { element } of promptElements) {
                // todo@connor4312: remove `flex` after transition
                flexBasisSum += (element.props.flex || element.props.flexBasis) ?? 1;
            }
            // Finally calculate the final sizing for each element in this group.
            const elementSizings = promptElements.map(e => {
                const proportion = (e.element.props.flexBasis ?? 1) / flexBasisSum;
                return {
                    tokenBudget: Math.floor(sizing.remainingTokenBudget * proportion),
                    endpoint: sizing.endpoint,
                    countTokens: (text, cancellation) => this._tokenizer.tokenLength(text, cancellation)
                };
            });
            // Free the previously-reserved budget now that we calculated sizing
            setReserved(groupIndex, false);
            await Promise.all(promptElements.map(async ({ element, promptElementInstance }, i) => {
                const state = await promptElementInstance.prepare?.(elementSizings[i], progress, token);
                element.node.setState(state);
            }));
            // Render
            for (const [i, { element, promptElementInstance, order }] of promptElements.entries()) {
                const elementSizing = elementSizings[i];
                const template = promptElementInstance.render(element.node.getState(), elementSizing);
                if (!template) {
                    // it doesn't want to render anything
                    continue;
                }
                const pieces = flattenAndReduce(template);
                // Compute token budget for the pieces that this child wants to render
                const childSizing = new PromptSizingContext(elementSizing.tokenBudget, this._endpoint);
                const { tokensConsumed } = await computeTokensConsumedByLiterals(this._tokenizer, element, promptElementInstance, pieces);
                childSizing.consume(tokensConsumed);
                await this._handlePromptChildren(element, pieces, childSizing, progress, token);
                // Tally up the child consumption into the parent context for any subsequent flex group
                sizing.consume(childSizing.consumed);
            }
        }
    }
    async _prioritize(things, cmp, count) {
        const prioritizedChunks = []; // sorted by descending priority
        const chunkResult = [];
        let i = 0;
        while (i < things.length) {
            // We only consider non-linebreaks for prioritization
            if (!things[i].isImplicitLinebreak) {
                const chunk = things[i - 1]?.isImplicitLinebreak ? { index: i, precedingLinebreak: i - 1 } : { index: i };
                prioritizedChunks.push(chunk);
                chunkResult[i] = null;
            }
            i += 1;
        }
        prioritizedChunks.sort((a, b) => cmp(things[a.index], things[b.index]));
        let remainingBudget = this._endpoint.modelMaxPromptTokens;
        while (prioritizedChunks.length > 0) {
            const prioritizedChunk = prioritizedChunks.shift();
            const index = prioritizedChunk.index;
            const chunk = things[index];
            let tokenCount = await count(chunk);
            let precedingLinebreak;
            if (prioritizedChunk.precedingLinebreak) {
                precedingLinebreak = things[prioritizedChunk.precedingLinebreak];
                tokenCount += await count(precedingLinebreak);
            }
            if (tokenCount > remainingBudget) {
                // Wouldn't fit anymore
                break;
            }
            chunkResult[index] = chunk;
            if (prioritizedChunk.precedingLinebreak && precedingLinebreak) {
                chunkResult[prioritizedChunk.precedingLinebreak] = precedingLinebreak;
            }
            remainingBudget -= tokenCount;
        }
        return { result: (0, arrays_1.coalesce)(chunkResult), tokenCount: this._endpoint.modelMaxPromptTokens - remainingBudget };
    }
    /**
     * Renders the prompt element and its children.
     * @returns A promise that resolves to an object containing the rendered chat messages and the total token count.
     * The total token count is guaranteed to be less than or equal to the token budget.
     */
    async render(progress, token) {
        // Convert root prompt element to prompt pieces
        await this._processPromptPieces(new PromptSizingContext(this._endpoint.modelMaxPromptTokens, this._endpoint), [{ node: this._root, ctor: this._ctor, props: this._props, children: [] }], progress, token);
        // Convert prompt pieces to message chunks (text and linebreaks)
        const { result: messageChunks, resultChunks } = this._root.materialize();
        // First pass: sort message chunks by priority. Note that this can yield an imprecise result due to token boundaries within a single chat message
        // so we also need to do a second pass over the full chat messages later
        const chunkMessages = new Set();
        const { result: prioritizedChunks } = await this._prioritize(resultChunks, (a, b) => MaterializedChatMessageTextChunk.cmp(a, b), async (chunk) => {
            let tokenLength = await this._tokenizer.tokenLength(chunk.text);
            if (!chunkMessages.has(chunk.message)) {
                chunkMessages.add(chunk.message);
                tokenLength = await this._tokenizer.countMessageTokens(chunk.toChatMessage());
            }
            return tokenLength;
        });
        // Update chat messages with their chunks that survived prioritization
        const chatMessagesToChunks = new Map();
        for (const chunk of (0, arrays_1.coalesce)(prioritizedChunks)) {
            const value = chatMessagesToChunks.get(chunk.message) ?? [];
            value[chunk.childIndex] = chunk;
            chatMessagesToChunks.set(chunk.message, value);
        }
        // Collect chat messages with surviving prioritized chunks in the order they were declared
        const chatMessages = [];
        for (const message of messageChunks) {
            const chunks = chatMessagesToChunks.get(message);
            if (chunks) {
                message.chunks = (0, arrays_1.coalesce)(chunks);
                for (const chunk of chunks) {
                    if (chunk && chunk.references.length > 0) {
                        message.references.push(...chunk.references);
                    }
                }
                chatMessages.push(message);
            }
        }
        // Second pass: make sure the chat messages will fit within the token budget
        const { result: prioritizedMaterializedChatMessages, tokenCount } = await this._prioritize(chatMessages, (a, b) => MaterializedChatMessage.cmp(a, b), async (message) => this._tokenizer.countMessageTokens(message.toChatMessage()));
        // Then finalize the chat messages
        const messageResult = prioritizedMaterializedChatMessages.map(message => message?.toChatMessage());
        // Remove undefined and duplicate references
        const { references } = prioritizedMaterializedChatMessages.reduce((acc, message) => {
            [...this._references, ...message.references].forEach((ref) => {
                const isVariableName = 'variableName' in ref.anchor;
                if (isVariableName && !acc.names.has(ref.anchor.variableName)) {
                    acc.references.push(ref);
                    acc.names.add(ref.anchor.variableName);
                }
                else if (!isVariableName) {
                    acc.references.push(ref);
                }
            });
            return acc;
        }, { references: [], names: new Set() });
        return { messages: messageResult, hasIgnoredFiles: this._ignoredFiles.length > 0, tokenCount, references: (0, arrays_1.coalesce)(references) };
    }
    _handlePromptChildren(element, pieces, sizing, progress, token) {
        if (element.ctor === promptElements_1.TextChunk) {
            this._handleExtrinsicTextChunkChildren(element.node.parent, element.props, pieces);
            return;
        }
        let todo = [];
        for (const piece of pieces) {
            if (piece.kind === 'literal') {
                element.node.appendStringChild(piece.value, element.props.priority ?? Number.MAX_SAFE_INTEGER);
                continue;
            }
            if (piece.kind === 'intrinsic') {
                // intrinsic element
                this._handleIntrinsic(element.node, piece.name, { priority: element.props.priority ?? Number.MAX_SAFE_INTEGER, ...piece.props }, flattenAndReduceArr(piece.children));
                continue;
            }
            const childNode = element.node.createChild();
            todo.push({ node: childNode, ctor: piece.ctor, props: { priority: element.props.priority, ...piece.props }, children: piece.children });
        }
        return this._processPromptPieces(sizing, todo, progress, token);
    }
    _handleIntrinsic(node, name, props, children) {
        switch (name) {
            case 'meta':
                return this._handleIntrinsicMeta(node, props, children);
            case 'br':
                return this._handleIntrinsicLineBreak(node, props, children, props.priority);
            case 'usedContext':
                return this._handleIntrinsicUsedContext(node, props, children);
            case 'references':
                return this._handleIntrinsicReferences(node, props, children);
            case 'ignoredFiles':
                return this._handleIntrinsicIgnoredFiles(node, props, children);
        }
        throw new Error(`Unknown intrinsic element ${name}!`);
    }
    _handleIntrinsicMeta(node, props, children) {
        if (children.length > 0) {
            throw new Error(`<meta /> must not have children!`);
        }
        const key = Object.getPrototypeOf(props.value).constructor;
        if (this._meta.has(key)) {
            throw new Error(`Duplicate metadata ${key.name}!`);
        }
        this._meta.set(key, props.value);
    }
    _handleIntrinsicLineBreak(node, props, children, inheritedPriority) {
        if (children.length > 0) {
            throw new Error(`<br /> must not have children!`);
        }
        node.appendLineBreak(true, inheritedPriority ?? Number.MAX_SAFE_INTEGER);
    }
    _handleIntrinsicUsedContext(node, props, children) {
        if (children.length > 0) {
            throw new Error(`<usedContext /> must not have children!`);
        }
        this._usedContext.push(...props.value);
    }
    _handleIntrinsicReferences(node, props, children) {
        if (children.length > 0) {
            throw new Error(`<reference /> must not have children!`);
        }
        node.addReferences(props.value);
        this._references.push(...props.value);
    }
    _handleIntrinsicIgnoredFiles(node, props, children) {
        if (children.length > 0) {
            throw new Error(`<ignoredFiles /> must not have children!`);
        }
        this._ignoredFiles.push(...props.value);
    }
    /**
     * @param node Parent of the <TextChunk />
     * @param props Props of the <TextChunk />
     * @param children Rendered children of the <TextChunk />
     */
    _handleExtrinsicTextChunkChildren(node, props, children) {
        const content = [];
        const references = [];
        for (const child of children) {
            if (child.kind === 'extrinsic') {
                throw new Error('TextChunk cannot have extrinsic children!');
            }
            if (child.kind === 'literal') {
                content.push(child.value);
            }
            if (child.kind === 'intrinsic') {
                if (child.name === 'br') {
                    // Preserve newlines
                    content.push('\n');
                }
                else if (child.name === 'references') {
                    // For TextChunks, references must be propagated through the PromptText element that is appended to the node
                    references.push(...child.props.value);
                }
                else {
                    this._handleIntrinsic(node, child.name, child.props, flattenAndReduceArr(child.children));
                }
            }
        }
        node.appendLineBreak(false);
        node.appendStringChild(content.join(''), props?.priority ?? Number.MAX_SAFE_INTEGER, references);
    }
}
exports.PromptRenderer = PromptRenderer;
async function computeTokensConsumedByLiterals(tokenizer, element, instance, pieces) {
    let tokensConsumed = 0;
    if ((0, promptElements_1.isChatMessagePromptElement)(instance)) {
        tokensConsumed += await tokenizer.countMessageTokens({ role: element.props.role, content: '', ...(element.props.name ? { name: element.props.name } : undefined) });
        for (const piece of pieces) {
            if (piece.kind === 'literal') {
                tokensConsumed += await tokenizer.tokenLength(piece.value);
            }
        }
    }
    return { tokensConsumed };
}
// Flatten nested fragments and normalize children
function flattenAndReduce(c) {
    if (typeof c === 'undefined' || typeof c === 'boolean') {
        // booleans are ignored to allow for the pattern: { cond && <Element ... /> }
        return [];
    }
    else if (typeof c === 'string' || typeof c === 'number') {
        return [new LiteralPromptPiece(String(c))];
    }
    else if (isFragmentCtor(c)) {
        return [...flattenAndReduceArr(c.children)];
    }
    else if (typeof c.ctor === 'string') {
        // intrinsic element
        return [new IntrinsicPromptPiece(c.ctor, c.props, c.children)];
    }
    else {
        // extrinsic element
        return [new ExtrinsicPromptPiece(c.ctor, c.props, c.children)];
    }
}
function flattenAndReduceArr(arr) {
    return (arr ?? []).reduce((r, c) => {
        r.push(...flattenAndReduce(c));
        return r;
    }, []);
}
class IntrinsicPromptPiece {
    constructor(name, props, children) {
        this.name = name;
        this.props = props;
        this.children = children;
        this.kind = 'intrinsic';
    }
}
class ExtrinsicPromptPiece {
    constructor(ctor, props, children) {
        this.ctor = ctor;
        this.props = props;
        this.children = children;
        this.kind = 'extrinsic';
    }
}
class LiteralPromptPiece {
    constructor(value, priority) {
        this.value = value;
        this.priority = priority;
        this.kind = 'literal';
    }
}
/**
 * A shared instance given to each PromptTreeElement that contains information
 * about the parent sizing and its children.
 */
class PromptSizingContext {
    constructor(tokenBudget, endpoint) {
        this.tokenBudget = tokenBudget;
        this.endpoint = endpoint;
        this._consumed = 0;
    }
    get consumed() {
        return this._consumed > this.tokenBudget ? this.tokenBudget : this._consumed;
    }
    get remainingTokenBudget() {
        return Math.max(0, this.tokenBudget - this._consumed);
    }
    /** Marks part of the budget as having been consumed by a render() call. */
    consume(budget) {
        this._consumed += budget;
    }
}
class PromptTreeElement {
    constructor(parent = null, childIndex) {
        this.parent = parent;
        this.childIndex = childIndex;
        this.kind = 0 /* PromptNodeType.Piece */;
        this._obj = null;
        this._state = undefined;
        this._children = [];
        this._references = [];
    }
    setObj(obj) {
        this._obj = obj;
    }
    setState(state) {
        this._state = state;
    }
    getState() {
        return this._state;
    }
    createChild() {
        const child = new PromptTreeElement(this, this._children.length);
        this._children.push(child);
        return child;
    }
    appendStringChild(text, priority, references) {
        this._children.push(new PromptText(this, text, priority, references));
    }
    appendLineBreak(explicit = true, priority) {
        this._children.push(new PromptLineBreak(this, explicit, priority));
    }
    materialize() {
        const result = [];
        const resultChunks = [];
        this._materialize(result, resultChunks);
        return { result, resultChunks };
    }
    _materialize(result, resultChunks) {
        if (this._obj instanceof promptElements_1.BaseChatMessage) {
            if (!this._obj.props.role) {
                throw new Error(`Invalid ChatMessage!`);
            }
            const leafNodes = [];
            for (const child of this._children) {
                child.collectLeafs(leafNodes);
            }
            const chunks = [];
            const parent = new MaterializedChatMessage(this._obj.props.role, this._obj.props.name, this._obj.props.priority, this.childIndex, chunks);
            let childIndex = resultChunks.length;
            leafNodes.forEach((node, index) => {
                if (node.kind === 1 /* PromptNodeType.Text */) {
                    chunks.push(new MaterializedChatMessageTextChunk(parent, node.text, node.priority, childIndex++, false, node.references ?? this._references));
                }
                else {
                    if (node.isExplicit) {
                        chunks.push(new MaterializedChatMessageTextChunk(parent, '\n', node.priority, childIndex++));
                    }
                    else if (chunks.length > 0 && chunks[chunks.length - 1].text !== '\n' || chunks[index - 1] && chunks[index - 1].text !== '\n') {
                        // Only insert an implicit linebreak if there wasn't already an explicit linebreak before
                        chunks.push(new MaterializedChatMessageTextChunk(parent, '\n', node.priority, childIndex++, true));
                    }
                }
            });
            resultChunks.push(...chunks);
            result.push(parent);
        }
        else {
            for (const child of this._children) {
                if (child.kind === 1 /* PromptNodeType.Text */) {
                    throw new Error(`Cannot have a text node outside a ChatMessage. Text: "${child.text}"`);
                }
                else if (child.kind === 2 /* PromptNodeType.LineBreak */) {
                    throw new Error(`Cannot have a line break node outside a ChatMessage!`);
                }
                child._materialize(result, resultChunks);
            }
        }
    }
    collectLeafs(result) {
        if (this._obj instanceof promptElements_1.BaseChatMessage) {
            throw new Error(`Cannot have a ChatMessage nested inside a ChatMessage!`);
        }
        if (this._obj?.insertLineBreakBefore) {
            // Add an implicit <br/> before the element
            result.push(new PromptLineBreak(this, false));
        }
        for (const child of this._children) {
            child.collectLeafs(result);
        }
    }
    addReferences(references) {
        this._references.push(...references);
    }
}
class MaterializedChatMessageTextChunk {
    constructor(message, text, priority, childIndex, isImplicitLinebreak = false, references = []) {
        this.message = message;
        this.text = text;
        this.priority = priority;
        this.childIndex = childIndex;
        this.isImplicitLinebreak = isImplicitLinebreak;
        this.references = references;
    }
    static cmp(a, b) {
        if (a.priority !== undefined && b.priority !== undefined && a.priority === b.priority) {
            // If the chunks share the same parent, break priority ties based on the order
            // that the chunks were declared in under its parent chat message
            if (a.message === b.message) {
                return a.childIndex - b.childIndex;
            }
            // Otherwise, prioritize chunks that were declared last
            return b.childIndex - a.childIndex;
        }
        if (a.priority !== undefined && b.priority !== undefined && a.priority !== b.priority) {
            return b.priority - a.priority;
        }
        return a.childIndex - b.childIndex;
    }
    toChatMessage() {
        return {
            role: this.message.role,
            content: this.text,
            ...(this.message.name ? { name: this.message.name } : {})
        };
    }
}
class MaterializedChatMessage {
    constructor(role, name, priority, childIndex, _chunks, references = []) {
        this.role = role;
        this.name = name;
        this.priority = priority;
        this.childIndex = childIndex;
        this._chunks = _chunks;
        this.references = references;
    }
    set chunks(chunks) {
        this._chunks = chunks.sort(MaterializedChatMessageTextChunk.cmp);
    }
    get text() {
        return this._chunks.reduce((acc, c, i) => {
            if (i !== (this._chunks.length - 1) || !c.isImplicitLinebreak) {
                acc += c.text;
            }
            return acc;
        }, '');
    }
    toChatMessage() {
        return {
            role: this.role,
            content: this.text,
            ...(this.name ? { name: this.name } : {})
        };
    }
    static cmp(a, b) {
        if (a.priority !== b.priority) {
            return (b.priority || 0) - (a.priority || 0);
        }
        return b.childIndex - a.childIndex;
    }
}
class PromptText {
    constructor(parent, text, priority, references) {
        this.parent = parent;
        this.text = text;
        this.priority = priority;
        this.references = references;
        this.kind = 1 /* PromptNodeType.Text */;
    }
    collectLeafs(result) {
        result.push(this);
    }
}
class PromptLineBreak {
    constructor(parent, isExplicit, priority) {
        this.parent = parent;
        this.isExplicit = isExplicit;
        this.priority = priority;
        this.kind = 2 /* PromptNodeType.LineBreak */;
    }
    collectLeafs(result) {
        result.push(this);
    }
}
function isFragmentCtor(template) {
    return (typeof template.ctor === 'function' && template.ctor.isFragment) ?? false;
}
