import type { CancellationToken, Progress } from "vscode";
import { ChatMessage, ChatRole } from "./openai";
import { PromptElement } from "./promptElement";
import { PromptMetadata, PromptReference } from "./results";
import { ITokenizer } from "./tokenizer/tokenizer";
import { BasePromptElementProps, IChatEndpointInfo, PromptElementCtor, PromptPieceChild } from "./types";
import { URI } from "./util/vs/common/uri";
import { ChatDocumentContext, ChatResponsePart } from "./vscodeTypes";
export interface RenderPromptResult {
    readonly messages: ChatMessage[];
    readonly tokenCount: number;
    readonly hasIgnoredFiles: boolean;
    /**
     * The references that survived prioritization in the rendered {@link RenderPromptResult.messages messages}.
     */
    readonly references: PromptReference[];
}
export type QueueItem<C, P> = {
    node: PromptTreeElement;
    ctor: C;
    props: P;
    children: PromptPieceChild[];
};
export interface MetadataMap {
    get<T extends PromptMetadata>(key: new (...args: any[]) => T): T | undefined;
}
export declare namespace MetadataMap {
    const empty: MetadataMap;
}
/**
 * A prompt renderer is responsible for rendering a {@link PromptElementCtor prompt element} to {@link ChatMessagePromptElement chat messages}.
 *
 * Note: You must create a fresh prompt renderer instance for each prompt element you want to render.
 */
export declare class PromptRenderer<P extends BasePromptElementProps> {
    private readonly _endpoint;
    private readonly _ctor;
    private readonly _props;
    private readonly _tokenizer;
    private readonly _meta;
    private readonly _usedContext;
    private readonly _ignoredFiles;
    private readonly _root;
    private readonly _references;
    /**
     *
     * @param _endpoint The chat endpoint that the rendered prompt will be sent to.
     * @param _ctor The prompt element constructor to render.
     * @param _props The props to pass to the prompt element.
     */
    constructor(_endpoint: IChatEndpointInfo, _ctor: PromptElementCtor<P, any>, _props: P, _tokenizer: ITokenizer);
    getAllMeta(): MetadataMap;
    getIgnoredFiles(): URI[];
    getMeta<T extends PromptMetadata>(key: new (...args: any[]) => T): T | undefined;
    getUsedContext(): ChatDocumentContext[];
    protected createElement(element: QueueItem<PromptElementCtor<P, any>, P>): PromptElement<P, any>;
    private _processPromptPieces;
    private _prioritize;
    /**
     * Renders the prompt element and its children.
     * @returns A promise that resolves to an object containing the rendered chat messages and the total token count.
     * The total token count is guaranteed to be less than or equal to the token budget.
     */
    render(progress?: Progress<ChatResponsePart>, token?: CancellationToken): Promise<RenderPromptResult>;
    private _handlePromptChildren;
    private _handleIntrinsic;
    private _handleIntrinsicMeta;
    private _handleIntrinsicLineBreak;
    private _handleIntrinsicUsedContext;
    private _handleIntrinsicReferences;
    private _handleIntrinsicIgnoredFiles;
    /**
     * @param node Parent of the <TextChunk />
     * @param props Props of the <TextChunk />
     * @param children Rendered children of the <TextChunk />
     */
    private _handleExtrinsicTextChunkChildren;
}
declare const enum PromptNodeType {
    Piece = 0,
    Text = 1,
    LineBreak = 2
}
type LeafPromptNode = PromptText | PromptLineBreak;
declare class PromptTreeElement {
    readonly parent: PromptTreeElement | null;
    readonly childIndex: number;
    readonly kind = PromptNodeType.Piece;
    private _obj;
    private _state;
    private _children;
    private _references;
    constructor(parent: PromptTreeElement | null, childIndex: number);
    setObj(obj: PromptElement): void;
    setState(state: any): void;
    getState(): any;
    createChild(): PromptTreeElement;
    appendStringChild(text: string, priority?: number, references?: PromptReference[]): void;
    appendLineBreak(explicit?: boolean, priority?: number): void;
    materialize(): {
        result: MaterializedChatMessage[];
        resultChunks: MaterializedChatMessageTextChunk[];
    };
    private _materialize;
    collectLeafs(result: LeafPromptNode[]): void;
    addReferences(references: PromptReference[]): void;
}
interface Countable {
    text: string;
    isImplicitLinebreak?: boolean;
}
declare class MaterializedChatMessageTextChunk implements Countable {
    readonly message: MaterializedChatMessage;
    readonly text: string;
    private readonly priority;
    readonly childIndex: number;
    readonly isImplicitLinebreak: boolean;
    readonly references: PromptReference[];
    constructor(message: MaterializedChatMessage, text: string, priority: number | undefined, childIndex: number, isImplicitLinebreak?: boolean, references?: PromptReference[]);
    static cmp(a: MaterializedChatMessageTextChunk, b: MaterializedChatMessageTextChunk): number;
    toChatMessage(): {
        name?: string | undefined;
        role: ChatRole;
        content: string;
    };
}
declare class MaterializedChatMessage implements Countable {
    readonly role: ChatRole;
    readonly name: string | undefined;
    private readonly priority;
    private readonly childIndex;
    private _chunks;
    references: PromptReference[];
    constructor(role: ChatRole, name: string | undefined, priority: number | undefined, childIndex: number, _chunks: MaterializedChatMessageTextChunk[], references?: PromptReference[]);
    set chunks(chunks: MaterializedChatMessageTextChunk[]);
    get text(): string;
    toChatMessage(): ChatMessage;
    static cmp(a: MaterializedChatMessage, b: MaterializedChatMessage): number;
}
declare class PromptText {
    readonly parent: PromptTreeElement;
    readonly text: string;
    readonly priority?: number | undefined;
    readonly references?: PromptReference[] | undefined;
    readonly kind = PromptNodeType.Text;
    constructor(parent: PromptTreeElement, text: string, priority?: number | undefined, references?: PromptReference[] | undefined);
    collectLeafs(result: LeafPromptNode[]): void;
}
declare class PromptLineBreak {
    readonly parent: PromptTreeElement;
    readonly isExplicit: boolean;
    readonly priority?: number | undefined;
    readonly kind = PromptNodeType.LineBreak;
    constructor(parent: PromptTreeElement, isExplicit: boolean, priority?: number | undefined);
    collectLeafs(result: LeafPromptNode[]): void;
}
export {};
